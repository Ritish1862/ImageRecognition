# -*- coding: utf-8 -*-
"""FLDM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k5uCmVyEBBlOdsn4hyPclHzfQwf7Ot30
"""

import numpy as np
import pandas as pd
import random
import math
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.cm as cm

df=pd.read_csv("/content/drive/MyDrive/ML/Dsata Set for Assignment 1.csv")

"""### Substituting for Missing values"""

import math as m
for col in df.columns:
  if(col[1].isdigit()):
    mean = df[col].mean()
    df[col] = df[col].fillna(mean)
  else:
    most_frequent_value = df[col].mode()[0]
    df[col] = df[col].fillna(most_frequent_value)

for col in df.columns:
  nan_values = df[df[col].isnull()]

"""### Normalization"""

for col in df.columns:
  if df[col].dtype != 'object' and col!='id':
    means = df[col].mean()
    stds = df[col].std()
    df[col] = (df[col] - means) / stds

class LDA():

    def __init__(self):
        self.w = None
        self.threshold = None
        self.less_class = None
        self.more_class = None
        self.X_transformed0 = None
        self.X_transformed1 = None

    def fit(self, X, y):

        X0 = X[y == 0]
        X1 = X[y == 1]

        mean0 = X0.mean(axis=0)
        mean1 = X1.mean(axis=0)
        diff_means = mean0 - mean1

        N = np.shape(X)[0]

        sw0 = np.array((1 / N) * (X0 - X0.mean(axis=0)).T.dot(X0 - X0.mean(axis=0)))
        sw1 = np.array((1 / N) * (X1 - X1.mean(axis=0)).T.dot(X1 - X1.mean(axis=0)))
        sw = sw0 + sw1

        self.w = np.linalg.pinv(sw).dot(diff_means)
        self.w = self.w / np.linalg.norm(self.w)
        X_t = self.transform(X)
        self.fit_normal_dist(X, y)

    def fit_transform(self, X, y):
        self.fit(X, y)
        X_transform = self.transform(X)
        return X_transform

    def transform(self, X):
        # Project data onto vector
        X_transform = X.dot(self.w)
        return X_transform

    def fit_normal_dist(self, X, y):
        X_transformed = self.transform(X)
        self.X_transformed0 = X_transformed[y == 0]
        self.X_transformed1 = X_transformed[y == 1]
        print(len(self.X_transformed0))
        print(len(self.X_transformed1))

        mean_transformed0 = self.X_transformed0.mean(axis=0)
        mean_transformed1 = self.X_transformed1.mean(axis=0)
        print("mean1",mean_transformed0)
        print("mean2",mean_transformed1)

        variation_transformed0 = np.var(self.X_transformed0)
        variation_transformed1 = np.var(self.X_transformed1)
        print("var1",variation_transformed0)
        print("var2",variation_transformed1)


        a = 0.5 * ((1/variation_transformed0) - (1/variation_transformed1))
        b = 2 * ((mean_transformed1/variation_transformed1) - (mean_transformed0/variation_transformed0))
        c = (((mean_transformed0 ** 2) / variation_transformed0) - ((mean_transformed1 ** 2) / variation_transformed1)) + np.log(variation_transformed0 / variation_transformed1)

        print("a",a)
        print("b",b)
        print("c",c)

        D = np.sqrt((b ** 2) - (4 * a * c))

        root1 = ((-b) + D) / (2 * a)
        root2 = ((-b) - D) / (2 * a)

        if((root1 > mean_transformed1 and root1 < mean_transformed0) or (root1 > mean_transformed0 and root1 < mean_transformed1)):
            self.threshold = root1
        elif((root2 > mean_transformed1 and root2 < mean_transformed0) or (root2 > mean_transformed0 and root2 < mean_transformed1)):
            self.threshold = root2

        if((mean_transformed0 <= self.threshold) and (mean_transformed1 >= self.threshold)):
            self.less_class = 0
            self.more_class = 1
        if((mean_transformed1 <= self.threshold) and (mean_transformed0 >= self.threshold)):
            self.less_class = 1
            self.more_class = 0
    def evaluate(self, X, y):
        y_pred = self.transform(X)
        more_idx = np.where(y_pred > self.threshold)[0]
        less_idx = np.where(y_pred <= self.threshold)[0]
        y_pred[more_idx] = self.more_class
        y_pred[less_idx] = self.less_class
        return (np.sum(y == y_pred) / len(y))

# Split the dataset into features and labels
X = df.drop(['diagnosis','id'], axis=1).values
y = df['diagnosis'].values

y[y=='M']=0
y[y=='B']=1

# assume X and y are the feature matrix and target vector, respectively

# shuffle the indices of the data
indices = list(range(len(X)))
random.shuffle(indices)

# calculate the split point
split_idx = int(0.67 * len(X))


# split the data into training and testing sets
X_train = X[indices[:split_idx]]
y_train = y[indices[:split_idx]]
X_test = X[indices[split_idx:]]
y_test = y[indices[split_idx:]]
# print(len(X_train))
l = LDA()
l.fit_transform(X_train,y_train)
print(f'Accuracy is: {l.evaluate(X_test, y_test)}')
print("Boundary point:",l.threshold)

def normal_pdf(x, mu, var):
    return (1 / np.sqrt(2 * np.pi * var)) * np.exp(-0.5 * ((x - mu)**2) / var)

from matplotlib.lines import Line2D
fig = plt.figure(figsize=(20, 10))
plt.ylim(-.1, 5)
plt.xlim(-2.5, 2.5)

lines = [Line2D([0], [0], color='blue', linewidth=3, linestyle='-'),
        Line2D([0], [0], color='green', linewidth=3, linestyle='-')]
labels = ['0', '1']
plt.legend(lines, labels)

plt.plot(l.X_transformed0, np.zeros_like(l.X_transformed0), 'x', color='blue')
plt.plot(l.X_transformed1, np.zeros_like(l.X_transformed1), 'o', color='green')
x_plot = np.linspace(-50, 50, 10000)
y_0 = normal_pdf(x_plot, np.mean(l.X_transformed0), np.var(l.X_transformed0))
y_1 = normal_pdf(x_plot, np.mean(l.X_transformed1), np.var(l.X_transformed1))
plt.fill_between(x_plot, y_0, color='blue', alpha=0.2)
plt.fill_between(x_plot, y_1, color='green', alpha=0.2)
plt.plot([l.threshold for x in x_plot], x_plot, color='red')

"""### FLDM2"""

X_permuted=X[:,np.random.permutation(X.shape[1])]

# now X_permuted_fixed has the same order of permutation for every row
X_train =X_permuted[indices[:split_idx]]
y_train =y[indices[:split_idx]]
X_test= X_permuted[indices[split_idx:]]
y_test= y[indices[split_idx:]]

l = LDA()
l.fit_transform(X_train,y_train)
print(f'Accuracy is: {l.evaluate(X_test, y_test)}')
print("Boundary point:",l.threshold)

def normal_pdf(x, mu, var):
    return (1 / np.sqrt(2 * np.pi * var)) * np.exp(-0.5 * ((x - mu)**2) / var)

from matplotlib.lines import Line2D
fig = plt.figure(figsize=(20, 10))
plt.ylim(-.1, 5)
plt.xlim(-2.5, 2.5)

lines = [Line2D([0], [0], color='blue', linewidth=3, linestyle='-'),
        Line2D([0], [0], color='green', linewidth=3, linestyle='-')]
labels = ['0', '1']
plt.legend(lines, labels)

plt.plot(l.X_transformed0, np.zeros_like(l.X_transformed0), 'x', color='blue')
plt.plot(l.X_transformed1, np.zeros_like(l.X_transformed1), 'o', color='green')
x_plot = np.linspace(-50, 50, 10000)
y_0 = normal_pdf(x_plot, np.mean(l.X_transformed0), np.var(l.X_transformed0))
y_1 = normal_pdf(x_plot, np.mean(l.X_transformed1), np.var(l.X_transformed1))
plt.fill_between(x_plot, y_0, color='blue', alpha=0.2)
plt.fill_between(x_plot, y_1, color='green', alpha=0.2)
plt.plot([l.threshold for x in x_plot], x_plot, color='red')